/*
 * Copyright (C) 2007 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.common.collect

import com.google.common.base.Preconditions.checkArgument
import com.google.common.base.Preconditions.checkNotNull
import com.google.common.collect.CollectPreconditions.checkRemove

import com.google.common.annotations.GwtCompatible
import com.google.common.collect.AbstractMultimap.Entries
import com.google.common.collect.AbstractMultimap.EntrySet
import com.google.common.collect.Maps.ViewCachingAbstractMap
import com.google.j2objc.annotations.WeakOuter
import java.io.Serializable
import java.util.AbstractCollection
import java.util.Collections
import java.util.Comparator
import java.util.ConcurrentModificationException
import kotlin.collections.Map.Entry
import java.util.NavigableMap
import java.util.NavigableSet
import java.util.RandomAccess
import java.util.SortedMap
import java.util.SortedSet
import java.util.Spliterator
import java.util.function.BiConsumer


/**
 * Basic implementation of the [Multimap] interface. This class represents a multimap as a map
 * that associates each key with a collection of values. All methods of [Multimap] are
 * supported, including those specified as optional in the interface.
 *
 *
 * To implement a multimap, a subclass must define the method [.createCollection], which
 * creates an empty collection of values for a key.
 *
 *
 * The multimap constructor takes a map that has a single entry for each distinct key. When you
 * insert a key-value pair with a key that isn't already in the multimap, `AbstractMapBasedMultimap` calls [.createCollection] to create the collection of values
 * for that key. The subclass should not call [.createCollection] directly, and a new
 * instance should be created every time the method is called.
 *
 *
 * For example, the subclass could pass a [java.util.TreeMap] during construction, and
 * [.createCollection] could return a [java.util.TreeSet], in which case the
 * multimap's iterators would propagate through the keys and values in sorted order.
 *
 *
 * Keys and values may be null, as long as the underlying collection classes support null
 * elements.
 *
 *
 * The collections created by [.createCollection] may or may not allow duplicates. If the
 * collection, such as a [Set], does not support duplicates, an added key-value pair will
 * replace an existing pair with the same key and value, if such a pair is present. With collections
 * like [List] that allow duplicates, the collection will keep the existing key-value pairs
 * while adding a new pair.
 *
 *
 * This class is not threadsafe when any concurrent operations update the multimap, even if the
 * underlying map and [.createCollection] method return threadsafe classes. Concurrent read
 * operations will work correctly. To allow concurrent update operations, wrap your multimap with a
 * call to [Multimaps.synchronizedMultimap].
 *
 *
 * For serialization to work, the subclass must specify explicit `readObject` and `writeObject` methods.
 *
 * @author Jared Levy
 * @author Louis Wasserman
 */
@GwtCompatible
internal abstract class AbstractMapBasedMultimap<K, V>
/**
 * Creates a new multimap that uses the provided map.
 *
 * @param map place to store the mapping from each key to its corresponding values
 * @throws IllegalArgumentException if `map` is not empty
 */
protected constructor(
        /*
   * Here's an outline of the overall design.
   *
   * The map variable contains the collection of values associated with each
   * key. When a key-value pair is added to a multimap that didn't previously
   * contain any values for that key, a new collection generated by
   * createCollection is added to the map. That same collection instance
   * remains in the map as long as the multimap has any values for the key. If
   * all values for the key are removed, the key and collection are removed
   * from the map.
   *
   * The get method returns a WrappedCollection, which decorates the collection
   * in the map (if the key is present) or an empty collection (if the key is
   * not present). When the collection delegate in the WrappedCollection is
   * empty, the multimap may contain subsequently added values for that key. To
   * handle that situation, the WrappedCollection checks whether map contains
   * an entry for the provided key, and if so replaces the delegate.
   */

        @field:Transient private var map: MutableMap<K, Collection<V>>?) : AbstractMultimap<K, V>(), Serializable {
    @Transient
    private var totalSize: Int = 0

    init {
        checkArgument(map.isEmpty())
    }

    /** Used during deserialization only.  */
    fun setMap(map: MutableMap<K, Collection<V>>) {
        this.map = map
        totalSize = 0
        for (values in map.values) {
            checkArgument(!values.isEmpty())
            totalSize += values.size
        }
    }

    /**
     * Creates an unmodifiable, empty collection of values.
     *
     *
     * This is used in [.removeAll] on an empty key.
     */
    internal open fun createUnmodifiableEmptyCollection(): Collection<V> {
        return unmodifiableCollectionSubclass(createCollection())
    }

    /**
     * Creates the collection of values for a single key.
     *
     *
     * Collections with weak, soft, or phantom references are not supported. Each call to `createCollection` should create a new instance.
     *
     *
     * The returned collection class determines whether duplicate key-value pairs are allowed.
     *
     * @return an empty collection of values
     */
    internal abstract fun createCollection(): MutableCollection<V>

    /**
     * Creates the collection of values for an explicitly provided key. By default, it simply calls
     * [.createCollection], which is the correct behavior for most implementations. The [ ] class overrides it.
     *
     * @param key key to associate with values in the collection
     * @return an empty collection of values
     */
    internal open fun createCollection(key: K): MutableCollection<V> {
        return createCollection()
    }

    internal open fun backingMap(): Map<K, Collection<V>>? {
        return map
    }

    // Query Operations

    override fun size(): Int {
        return totalSize
    }

    override fun containsKey(key: Any): Boolean {
        return map!!.containsKey(key)
    }

    // Modification Operations

    override fun put(key: K, value: V): Boolean {
        var collection: MutableCollection<V>? = map!![key]
        if (collection == null) {
            collection = createCollection(key)
            if (collection.add(value)) {
                totalSize++
                map!![key] = collection
                return true
            } else {
                throw AssertionError("New Collection violated the Collection spec")
            }
        } else if (collection.add(value)) {
            totalSize++
            return true
        } else {
            return false
        }
    }

    private fun getOrCreateCollection(key: K): MutableCollection<V> {
        var collection: Collection<V>? = map!![key]
        if (collection == null) {
            collection = createCollection(key)
            map!![key] = collection
        }
        return collection
    }

    // Bulk Operations

    /**
     * {@inheritDoc}
     *
     *
     * The returned collection is immutable.
     */
    override fun replaceValues(key: K, values: Iterable<V>): Collection<V> {
        val iterator = values.iterator()
        if (!iterator.hasNext()) {
            return removeAll(key)
        }

        // TODO(lowasser): investigate atomic failure?
        val collection = getOrCreateCollection(key)
        val oldValues = createCollection()
        oldValues.addAll(collection)

        totalSize -= collection.size
        collection.clear()

        while (iterator.hasNext()) {
            if (collection.add(iterator.next())) {
                totalSize++
            }
        }

        return unmodifiableCollectionSubclass(oldValues)
    }

    /**
     * {@inheritDoc}
     *
     *
     * The returned collection is immutable.
     */
    override fun removeAll(key: Any): Collection<V> {
        val collection = map!!.remove(key) ?: return createUnmodifiableEmptyCollection()

        val output = createCollection()
        output.addAll(collection)
        totalSize -= collection.size
        collection.clear()

        return unmodifiableCollectionSubclass(output)
    }

    internal open fun <E> unmodifiableCollectionSubclass(collection: Collection<E>): Collection<E> {
        return Collections.unmodifiableCollection(collection)
    }

    override fun clear() {
        // Clear each collection, to make previously returned collections empty.
        for (collection in map!!.values) {
            collection.clear()
        }
        map!!.clear()
        totalSize = 0
    }

    // Views

    /**
     * {@inheritDoc}
     *
     *
     * The returned collection is not serializable.
     */
    override fun get(key: K): Collection<V> {
        var collection: MutableCollection<V>? = map!![key]
        if (collection == null) {
            collection = createCollection(key)
        }
        return wrapCollection(key, collection)
    }

    /**
     * Generates a decorated collection that remains consistent with the values in the multimap for
     * the provided key. Changes to the multimap may alter the returned collection, and vice versa.
     */
    internal open fun wrapCollection(key: K, collection: MutableCollection<V>): Collection<V> {
        return WrappedCollection(key, collection, null)
    }

    fun wrapList(
            key: K, list: MutableList<V>, ancestor: WrappedCollection?): List<V> {
        return if (list is RandomAccess)
            RandomAccessWrappedList(key, list, ancestor)
        else
            WrappedList(key, list, ancestor)
    }

    /**
     * Collection decorator that stays in sync with the multimap values for a key. There are two kinds
     * of wrapped collections: full and subcollections. Both have a delegate pointing to the
     * underlying collection class.
     *
     *
     * Full collections, identified by a null ancestor field, contain all multimap values for a
     * given key. Its delegate is a value in [AbstractMapBasedMultimap.map] whenever the
     * delegate is non-empty. The `refreshIfEmpty`, `removeIfEmpty`, and `addToMap`
     * methods ensure that the `WrappedCollection` and map remain consistent.
     *
     *
     * A subcollection, such as a sublist, contains some of the values for a given key. Its
     * ancestor field points to the full wrapped collection with all values for the key. The
     * subcollection `refreshIfEmpty`, `removeIfEmpty`, and `addToMap` methods call
     * the corresponding methods of the full wrapped collection.
     */
    @WeakOuter
    internal open inner class WrappedCollection(
            val key: K, var delegate: MutableCollection<V>, val ancestor: WrappedCollection?) : AbstractCollection<V>() {
        val ancestorDelegate: Collection<V>?

        init {
            this.ancestorDelegate = ancestor?.getDelegate()
        }

        /**
         * If the delegate collection is empty, but the multimap has values for the key, replace the
         * delegate with the new collection for the key.
         *
         *
         * For a subcollection, refresh its ancestor and validate that the ancestor delegate hasn't
         * changed.
         */
        fun refreshIfEmpty() {
            if (ancestor != null) {
                ancestor.refreshIfEmpty()
                if (ancestor.getDelegate() !== ancestorDelegate) {
                    throw ConcurrentModificationException()
                }
            } else if (delegate.isEmpty()) {
                val newDelegate = map!![key]
                if (newDelegate != null) {
                    delegate = newDelegate
                }
            }
        }

        /**
         * If collection is empty, remove it from `AbstractMapBasedMultimap.this.map`. For
         * subcollections, check whether the ancestor collection is empty.
         */
        fun removeIfEmpty() {
            if (ancestor != null) {
                ancestor.removeIfEmpty()
            } else if (delegate.isEmpty()) {
                map!!.remove(key)
            }
        }

        /**
         * Add the delegate to the map. Other `WrappedCollection` methods should call this method
         * after adding elements to a previously empty collection.
         *
         *
         * Subcollection add the ancestor's delegate instead.
         */
        fun addToMap() {
            if (ancestor != null) {
                ancestor.addToMap()
            } else {
                map!![key] = delegate
            }
        }

        override fun size(): Int {
            refreshIfEmpty()
            return delegate.size
        }

        override fun equals(`object`: Any?): Boolean {
            if (`object` === this) {
                return true
            }
            refreshIfEmpty()
            return delegate == `object`
        }

        override fun hashCode(): Int {
            refreshIfEmpty()
            return delegate.hashCode()
        }

        override fun toString(): String {
            refreshIfEmpty()
            return delegate.toString()
        }

        fun getDelegate(): Collection<V> {
            return delegate
        }

        override fun iterator(): Iterator<V> {
            refreshIfEmpty()
            return WrappedIterator()
        }

        override fun spliterator(): Spliterator<V> {
            refreshIfEmpty()
            return delegate.spliterator()
        }

        /** Collection iterator for `WrappedCollection`.  */
        internal open inner class WrappedIterator : Iterator<V> {
            val delegateIterator: MutableIterator<V>
            val originalDelegate = delegate

            constructor() {
                delegateIterator = iteratorOrListIterator(delegate)
            }

            constructor(delegateIterator: MutableIterator<V>) {
                this.delegateIterator = delegateIterator
            }

            /**
             * If the delegate changed since the iterator was created, the iterator is no longer valid.
             */
            fun validateIterator() {
                refreshIfEmpty()
                if (delegate !== originalDelegate) {
                    throw ConcurrentModificationException()
                }
            }

            override fun hasNext(): Boolean {
                validateIterator()
                return delegateIterator.hasNext()
            }

            override fun next(): V {
                validateIterator()
                return delegateIterator.next()
            }

            override fun remove() {
                delegateIterator.remove()
                totalSize--
                removeIfEmpty()
            }

            fun getDelegateIterator(): Iterator<V> {
                validateIterator()
                return delegateIterator
            }
        }

        override fun add(value: V?): Boolean {
            refreshIfEmpty()
            val wasEmpty = delegate.isEmpty()
            val changed = delegate.add(value)
            if (changed) {
                totalSize++
                if (wasEmpty) {
                    addToMap()
                }
            }
            return changed
        }

        // The following methods are provided for better performance.

        override fun addAll(collection: Collection<V>): Boolean {
            if (collection.isEmpty()) {
                return false
            }
            val oldSize = size // calls refreshIfEmpty
            val changed = delegate.addAll(collection)
            if (changed) {
                val newSize = delegate.size
                totalSize += newSize - oldSize
                if (oldSize == 0) {
                    addToMap()
                }
            }
            return changed
        }

        override operator fun contains(o: Any?): Boolean {
            refreshIfEmpty()
            return delegate.contains(o)
        }

        override fun containsAll(c: Collection<*>): Boolean {
            refreshIfEmpty()
            return delegate.containsAll(c)
        }

        override fun clear() {
            val oldSize = size // calls refreshIfEmpty
            if (oldSize == 0) {
                return
            }
            delegate.clear()
            totalSize -= oldSize
            removeIfEmpty() // maybe shouldn't be removed if this is a sublist
        }

        override fun remove(o: Any?): Boolean {
            refreshIfEmpty()
            val changed = delegate.remove(o)
            if (changed) {
                totalSize--
                removeIfEmpty()
            }
            return changed
        }

        override fun removeAll(c: Collection<*>): Boolean {
            if (c.isEmpty()) {
                return false
            }
            val oldSize = size // calls refreshIfEmpty
            val changed = delegate.removeAll(c)
            if (changed) {
                val newSize = delegate.size
                totalSize += newSize - oldSize
                removeIfEmpty()
            }
            return changed
        }

        override fun retainAll(c: Collection<*>): Boolean {
            checkNotNull(c)
            val oldSize = size // calls refreshIfEmpty
            val changed = delegate.retainAll(c)
            if (changed) {
                val newSize = delegate.size
                totalSize += newSize - oldSize
                removeIfEmpty()
            }
            return changed
        }
    }

    /** Set decorator that stays in sync with the multimap values for a key.  */
    @WeakOuter
    internal inner class WrappedSet(key: K, delegate: MutableSet<V>) : WrappedCollection(key, delegate, null), Set<V> {

        override fun removeAll(c: Collection<*>): Boolean {
            if (c.isEmpty()) {
                return false
            }
            val oldSize = size // calls refreshIfEmpty

            // Guava issue 1013: AbstractSet and most JDK set implementations are
            // susceptible to quadratic removeAll performance on lists;
            // use a slightly smarter implementation here
            val changed = Sets.removeAllImpl(delegate as Set<V>, c)
            if (changed) {
                val newSize = delegate.size
                totalSize += newSize - oldSize
                removeIfEmpty()
            }
            return changed
        }
    }

    /** SortedSet decorator that stays in sync with the multimap values for a key.  */
    @WeakOuter
    internal open inner class WrappedSortedSet(
            key: K, delegate: SortedSet<V>, ancestor: WrappedCollection) : WrappedCollection(key, delegate, ancestor), SortedSet<V> {

        internal open val sortedSetDelegate: SortedSet<V>
            get() = getDelegate() as SortedSet<V>

        override fun comparator(): Comparator<in V>? {
            return sortedSetDelegate.comparator()
        }

        override fun first(): V {
            refreshIfEmpty()
            return sortedSetDelegate.first()
        }

        override fun last(): V {
            refreshIfEmpty()
            return sortedSetDelegate.last()
        }

        override fun headSet(toElement: V): SortedSet<V> {
            refreshIfEmpty()
            return WrappedSortedSet(
                    key,
                    sortedSetDelegate.headSet(toElement),
                    ancestor ?: this)
        }

        override fun subSet(fromElement: V, toElement: V): SortedSet<V> {
            refreshIfEmpty()
            return WrappedSortedSet(
                    key,
                    sortedSetDelegate.subSet(fromElement, toElement),
                    ancestor ?: this)
        }

        override fun tailSet(fromElement: V): SortedSet<V> {
            refreshIfEmpty()
            return WrappedSortedSet(
                    key,
                    sortedSetDelegate.tailSet(fromElement),
                    ancestor ?: this)
        }
    }

    @WeakOuter
    internal inner class WrappedNavigableSet(
            key: K, delegate: NavigableSet<V>, ancestor: WrappedCollection) : WrappedSortedSet(key, delegate, ancestor), NavigableSet<V> {

        override val sortedSetDelegate: NavigableSet<V>
            get() = super.sortedSetDelegate as NavigableSet<V>

        override fun lower(v: V): V? {
            return sortedSetDelegate.lower(v)
        }

        override fun floor(v: V): V? {
            return sortedSetDelegate.floor(v)
        }

        override fun ceiling(v: V): V? {
            return sortedSetDelegate.ceiling(v)
        }

        override fun higher(v: V): V? {
            return sortedSetDelegate.higher(v)
        }

        override fun pollFirst(): V? {
            return Iterators.pollNext(iterator())
        }

        override fun pollLast(): V? {
            return Iterators.pollNext(descendingIterator())
        }

        private fun wrap(wrapped: NavigableSet<V>): NavigableSet<V> {
            return WrappedNavigableSet(key, wrapped, ancestor ?: this)
        }

        override fun descendingSet(): NavigableSet<V> {
            return wrap(sortedSetDelegate.descendingSet())
        }

        override fun descendingIterator(): Iterator<V> {
            return WrappedCollection.WrappedIterator(sortedSetDelegate.descendingIterator())
        }

        override fun subSet(
                fromElement: V, fromInclusive: Boolean, toElement: V, toInclusive: Boolean): NavigableSet<V> {
            return wrap(
                    sortedSetDelegate.subSet(fromElement, fromInclusive, toElement, toInclusive))
        }

        override fun headSet(toElement: V, inclusive: Boolean): NavigableSet<V> {
            return wrap(sortedSetDelegate.headSet(toElement, inclusive))
        }

        override fun tailSet(fromElement: V, inclusive: Boolean): NavigableSet<V> {
            return wrap(sortedSetDelegate.tailSet(fromElement, inclusive))
        }
    }

    /** List decorator that stays in sync with the multimap values for a key.  */
    @WeakOuter
    internal open inner class WrappedList(key: K, delegate: MutableList<V>, ancestor: WrappedCollection) : WrappedCollection(key, delegate, ancestor), List<V> {

        val listDelegate: MutableList<V>
            get() = getDelegate() as List<V>

        override fun addAll(index: Int, c: Collection<V>): Boolean {
            if (c.isEmpty()) {
                return false
            }
            val oldSize = size // calls refreshIfEmpty
            val changed = listDelegate.addAll(index, c)
            if (changed) {
                val newSize = getDelegate().size
                totalSize += newSize - oldSize
                if (oldSize == 0) {
                    addToMap()
                }
            }
            return changed
        }

        override fun get(index: Int): V {
            refreshIfEmpty()
            return listDelegate[index]
        }

        override operator fun set(index: Int, element: V): V {
            refreshIfEmpty()
            return listDelegate.set(index, element)
        }

        override fun add(index: Int, element: V) {
            refreshIfEmpty()
            val wasEmpty = getDelegate().isEmpty()
            listDelegate.add(index, element)
            totalSize++
            if (wasEmpty) {
                addToMap()
            }
        }

        override fun remove(index: Int): V {
            refreshIfEmpty()
            val value = listDelegate.removeAt(index)
            totalSize--
            removeIfEmpty()
            return value
        }

        override fun indexOf(o: Any): Int {
            refreshIfEmpty()
            return listDelegate.indexOf(o)
        }

        override fun lastIndexOf(o: Any): Int {
            refreshIfEmpty()
            return listDelegate.lastIndexOf(o)
        }

        override fun listIterator(): ListIterator<V> {
            refreshIfEmpty()
            return WrappedListIterator()
        }

        override fun listIterator(index: Int): ListIterator<V> {
            refreshIfEmpty()
            return WrappedListIterator(index)
        }

        override fun subList(fromIndex: Int, toIndex: Int): List<V> {
            refreshIfEmpty()
            return wrapList(
                    key,
                    listDelegate.subList(fromIndex, toIndex),
                    ancestor ?: this)
        }

        /** ListIterator decorator.  */
        private inner class WrappedListIterator : WrappedCollection.WrappedIterator, ListIterator<V> {

            private val delegateListIterator: MutableListIterator<V>
                get() = getDelegateIterator() as ListIterator<V>

            internal constructor() {}

            constructor(index: Int) : super(listDelegate.listIterator(index)) {}

            override fun hasPrevious(): Boolean {
                return delegateListIterator.hasPrevious()
            }

            override fun previous(): V {
                return delegateListIterator.previous()
            }

            override fun nextIndex(): Int {
                return delegateListIterator.nextIndex()
            }

            override fun previousIndex(): Int {
                return delegateListIterator.previousIndex()
            }

            override fun set(value: V) {
                delegateListIterator.set(value)
            }

            override fun add(value: V) {
                val wasEmpty = isEmpty()
                delegateListIterator.add(value)
                totalSize++
                if (wasEmpty) {
                    addToMap()
                }
            }
        }
    }

    /**
     * List decorator that stays in sync with the multimap values for a key and supports rapid random
     * access.
     */
    private inner class RandomAccessWrappedList internal constructor(
            key: K, delegate: MutableList<V>, ancestor: WrappedCollection) : WrappedList(key, delegate, ancestor), RandomAccess

    internal override fun createKeySet(): Set<K> {
        return KeySet(map)
    }

    fun createMaybeNavigableKeySet(): Set<K> {
        return if (map is NavigableMap<*, *>) {
            NavigableKeySet(map as NavigableMap<K, Collection<V>>?)
        } else if (map is SortedMap<*, *>) {
            SortedKeySet(map as SortedMap<K, Collection<V>>?)
        } else {
            KeySet(map)
        }
    }

    @WeakOuter
    private open inner class KeySet internal constructor(subMap: Map<K, Collection<V>>) : Maps.KeySet<K, Collection<V>>(subMap) {

        override fun iterator(): Iterator<K> {
            val entryIterator = map().entries.iterator()
            return object : Iterator<K> {
                internal var entry: Entry<K, Collection<V>>? = null

                override fun hasNext(): Boolean {
                    return entryIterator.hasNext()
                }

                override fun next(): K {
                    entry = entryIterator.next()
                    return entry!!.key
                }

                override fun remove() {
                    checkRemove(entry != null)
                    val collection = entry!!.value
                    entryIterator.remove()
                    totalSize -= collection.size
                    collection.clear()
                    entry = null
                }
            }
        }

        // The following methods are included for better performance.

        override fun spliterator(): Spliterator<K> {
            return map().keys.spliterator()
        }

        override fun remove(key: Any?): Boolean {
            var count = 0
            val collection = map().remove(key)
            if (collection != null) {
                count = collection.size
                collection.clear()
                totalSize -= count
            }
            return count > 0
        }

        override fun clear() {
            Iterators.clear(iterator())
        }

        override fun containsAll(c: Collection<*>): Boolean {
            return map().keys.containsAll(c)
        }

        override fun equals(`object`: Any?): Boolean {
            return this === `object` || this.map().keys == `object`
        }

        override fun hashCode(): Int {
            return map().keys.hashCode()
        }
    }

    @WeakOuter
    private open inner class SortedKeySet internal constructor(subMap: SortedMap<K, Collection<V>>) : KeySet(subMap), SortedSet<K> {

        internal open fun sortedMap(): SortedMap<K, Collection<V>> {
            return super.map() as SortedMap<K, Collection<V>>
        }

        override fun comparator(): Comparator<in K>? {
            return sortedMap().comparator()
        }

        override fun first(): K {
            return sortedMap().firstKey()
        }

        override fun headSet(toElement: K): SortedSet<K> {
            return SortedKeySet(sortedMap().headMap(toElement))
        }

        override fun last(): K {
            return sortedMap().lastKey()
        }

        override fun subSet(fromElement: K, toElement: K): SortedSet<K> {
            return SortedKeySet(sortedMap().subMap(fromElement, toElement))
        }

        override fun tailSet(fromElement: K): SortedSet<K> {
            return SortedKeySet(sortedMap().tailMap(fromElement))
        }
    }

    @WeakOuter
    internal inner class NavigableKeySet(subMap: NavigableMap<K, Collection<V>>) : SortedKeySet(subMap), NavigableSet<K> {

        override fun sortedMap(): NavigableMap<K, Collection<V>> {
            return super.sortedMap() as NavigableMap<K, Collection<V>>
        }

        override fun lower(k: K): K? {
            return sortedMap().lowerKey(k)
        }

        override fun floor(k: K): K? {
            return sortedMap().floorKey(k)
        }

        override fun ceiling(k: K): K? {
            return sortedMap().ceilingKey(k)
        }

        override fun higher(k: K): K? {
            return sortedMap().higherKey(k)
        }

        override fun pollFirst(): K? {
            return Iterators.pollNext(iterator())
        }

        override fun pollLast(): K? {
            return Iterators.pollNext(descendingIterator())
        }

        override fun descendingSet(): NavigableSet<K> {
            return NavigableKeySet(sortedMap().descendingMap())
        }

        override fun descendingIterator(): Iterator<K> {
            return descendingSet().iterator()
        }

        override fun headSet(toElement: K): NavigableSet<K> {
            return headSet(toElement, false)
        }

        override fun headSet(toElement: K, inclusive: Boolean): NavigableSet<K> {
            return NavigableKeySet(sortedMap().headMap(toElement, inclusive))
        }

        override fun subSet(fromElement: K, toElement: K): NavigableSet<K> {
            return subSet(fromElement, true, toElement, false)
        }

        override fun subSet(
                fromElement: K, fromInclusive: Boolean, toElement: K, toInclusive: Boolean): NavigableSet<K> {
            return NavigableKeySet(
                    sortedMap().subMap(fromElement, fromInclusive, toElement, toInclusive))
        }

        override fun tailSet(fromElement: K): NavigableSet<K> {
            return tailSet(fromElement, true)
        }

        override fun tailSet(fromElement: K, inclusive: Boolean): NavigableSet<K> {
            return NavigableKeySet(sortedMap().tailMap(fromElement, inclusive))
        }
    }

    /** Removes all values for the provided key.  */
    private fun removeValuesForKey(key: Any) {
        val collection = Maps.safeRemove(map, key)

        if (collection != null) {
            val count = collection.size
            collection.clear()
            totalSize -= count
        }
    }

    private abstract inner class Itr<T> internal constructor() : Iterator<T> {
        internal val keyIterator: MutableIterator<Entry<K, Collection<V>>>
        internal var key: K? = null

        internal var collection: MutableCollection<V>? = null
        internal var valueIterator: MutableIterator<V>

        init {
            keyIterator = map!!.entries.iterator()
            key = null
            collection = null
            valueIterator = Iterators.emptyModifiableIterator()
        }

        internal abstract fun output(key: K?, value: V): T

        override fun hasNext(): Boolean {
            return keyIterator.hasNext() || valueIterator.hasNext()
        }

        override fun next(): T {
            if (!valueIterator.hasNext()) {
                val mapEntry = keyIterator.next()
                key = mapEntry.key
                collection = mapEntry.value
                valueIterator = collection!!.iterator()
            }
            return output(key, valueIterator.next())
        }

        override fun remove() {
            valueIterator.remove()
            if (collection!!.isEmpty()) {
                keyIterator.remove()
            }
            totalSize--
        }
    }

    /**
     * {@inheritDoc}
     *
     *
     * The iterator generated by the returned collection traverses the values for one key, followed
     * by the values of a second key, and so on.
     */
    override fun values(): Collection<V> {
        return super.values()
    }

    internal override fun createValues(): Collection<V> {
        return AbstractMultimap.Values()
    }

    internal override fun valueIterator(): Iterator<V> {
        return object : Itr<V>() {
            override fun output(key: K?, value: V): V {
                return value
            }
        }
    }

    internal override fun valueSpliterator(): Spliterator<V> {
        return CollectSpliterators.flatMap(
                map!!.values.spliterator(), Function<Collection<V>, Spliterator<V>> { it.spliterator() }, Spliterator.SIZED, size().toLong())
    }

    /*
   * TODO(kevinb): should we copy this javadoc to each concrete class, so that
   * classes like LinkedHashMultimap that need to say something different are
   * still able to {@inheritDoc} all the way from Multimap?
   */

    internal override fun createKeys(): Multiset<K> {
        return Multimaps.Keys(this)
    }

    /**
     * {@inheritDoc}
     *
     *
     * The iterator generated by the returned collection traverses the values for one key, followed
     * by the values of a second key, and so on.
     *
     *
     * Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the
     * time the entry is returned by a method call to the collection or its iterator.
     */
    override fun entries(): Collection<Entry<K, V>> {
        return super.entries()
    }

    internal override fun createEntries(): Collection<Entry<K, V>> {
        return if (this is SetMultimap<*, *>) {
            EntrySet()
        } else {
            Entries()
        }
    }

    /**
     * Returns an iterator across all key-value map entries, used by `entries().iterator()` and
     * `values().iterator()`. The default behavior, which traverses the values for one key, the
     * values for a second key, and so on, suffices for most `AbstractMapBasedMultimap`
     * implementations.
     *
     * @return an iterator across map entries
     */
    internal override fun entryIterator(): Iterator<Entry<K, V>> {
        return object : Itr<Entry<K, V>>() {
            override fun output(key: K?, value: V): Entry<K, V> {
                return Maps.immutableEntry<K, V>(key, value)
            }
        }
    }

    internal override fun entrySpliterator(): Spliterator<Entry<K, V>> {
        return CollectSpliterators.flatMap<Entry<K, Collection<V>>, Entry<K, V>>(
                map!!.entries.spliterator(),
                { keyToValueCollectionEntry ->
                    val key = keyToValueCollectionEntry.key
                    val valueCollection = keyToValueCollectionEntry.value
                    CollectSpliterators.map(
                            valueCollection.spliterator()) { value: V -> Maps.immutableEntry<K, V>(key, value) }
                },
                Spliterator.SIZED,
                size().toLong())
    }

    override fun forEach(action: BiConsumer<in K, in V>) {
        checkNotNull(action)
        map!!.forEach { key, valueCollection -> valueCollection.forEach { value -> action.accept(key, value) } }
    }

    internal override fun createAsMap(): Map<K, Collection<V>> {
        return AsMap(map)
    }

    fun createMaybeNavigableAsMap(): Map<K, Collection<V>> {
        return if (map is NavigableMap<*, *>) {
            NavigableAsMap(map as NavigableMap<K, Collection<V>>?)
        } else if (map is SortedMap<*, *>) {
            SortedAsMap(map as SortedMap<K, Collection<V>>?)
        } else {
            AsMap(map)
        }
    }

    @WeakOuter
    private open inner class AsMap internal constructor(
            /**
             * Usually the same as map, but smaller for the headMap(), tailMap(), or subMap() of a
             * SortedAsMap.
             */
            @field:Transient internal val submap: MutableMap<K, Collection<V>>) : ViewCachingAbstractMap<K, Collection<V>>() {

        override fun createEntrySet(): Set<Entry<K, Collection<V>>> {
            return AsMapEntries()
        }

        // The following methods are included for performance.

        override fun containsKey(key: Any?): Boolean {
            return Maps.safeContainsKey(submap, key)
        }

        override operator fun get(key: Any?): Collection<V>? {
            val collection = Maps.safeGet(submap, key) ?: return null
            val k = key as K?
            return wrapCollection(k, collection)
        }

        override fun keySet(): Set<K> {
            return this@AbstractMapBasedMultimap.keySet()
        }

        override fun size(): Int {
            return submap.size
        }

        override fun remove(key: Any?): Collection<V>? {
            val collection = submap.remove(key) ?: return null

            val output = createCollection()
            output.addAll(collection)
            totalSize -= collection.size
            collection.clear()
            return output
        }

        override fun equals(`object`: Any?): Boolean {
            return this === `object` || submap == `object`
        }

        override fun hashCode(): Int {
            return submap.hashCode()
        }

        override fun toString(): String {
            return submap.toString()
        }

        override fun clear() {
            if (submap === map) {
                this@AbstractMapBasedMultimap.clear()
            } else {
                Iterators.clear(AsMapIterator())
            }
        }

        internal fun wrapEntry(entry: Entry<K, Collection<V>>): Entry<K, Collection<V>> {
            val key = entry.key
            return Maps.immutableEntry(key, wrapCollection(key, entry.value))
        }

        @WeakOuter
        internal inner class AsMapEntries : Maps.EntrySet<K, Collection<V>>() {
            internal override fun map(): Map<K, Collection<V>> {
                return this@AsMap
            }

            override fun iterator(): Iterator<Entry<K, Collection<V>>> {
                return AsMapIterator()
            }

            override fun spliterator(): Spliterator<Entry<K, Collection<V>>> {
                return CollectSpliterators.map<Entry<K, Collection<V>>, Entry<K, Collection<V>>>(submap.entries.spliterator(), Function<Entry<K, Collection<V>>, Entry<K, Collection<V>>> { this@AsMap.wrapEntry(it) })
            }

            // The following methods are included for performance.

            override operator fun contains(o: Any?): Boolean {
                return Collections2.safeContains(submap.entries, o)
            }

            override fun remove(o: Any?): Boolean {
                if (!contains(o)) {
                    return false
                }
                val entry = o as Entry<*, *>?
                removeValuesForKey(entry!!.key)
                return true
            }
        }

        /** Iterator across all keys and value collections.  */
        internal inner class AsMapIterator : Iterator<Entry<K, Collection<V>>> {
            val delegateIterator: MutableIterator<Entry<K, Collection<V>>> = submap.entries.iterator()
            var collection: MutableCollection<V>? = null

            override fun hasNext(): Boolean {
                return delegateIterator.hasNext()
            }

            override fun next(): Entry<K, Collection<V>> {
                val entry = delegateIterator.next()
                collection = entry.value
                return wrapEntry(entry)
            }

            override fun remove() {
                checkRemove(collection != null)
                delegateIterator.remove()
                totalSize -= collection!!.size
                collection!!.clear()
                collection = null
            }
        }
    }

    @WeakOuter
    private open inner class SortedAsMap internal constructor(submap: SortedMap<K, Collection<V>>) : AsMap(submap), SortedMap<K, Collection<V>> {


        internal var sortedKeySet: SortedSet<K>? = null

        internal open fun sortedMap(): SortedMap<K, Collection<V>> {
            return submap as SortedMap<K, Collection<V>>
        }

        override fun comparator(): Comparator<in K> {
            return sortedMap().comparator()
        }

        override fun firstKey(): K {
            return sortedMap().firstKey()
        }

        override fun lastKey(): K {
            return sortedMap().lastKey()
        }

        override fun headMap(toKey: K): SortedMap<K, Collection<V>> {
            return SortedAsMap(sortedMap().headMap(toKey))
        }

        override fun subMap(fromKey: K, toKey: K): SortedMap<K, Collection<V>> {
            return SortedAsMap(sortedMap().subMap(fromKey, toKey))
        }

        override fun tailMap(fromKey: K): SortedMap<K, Collection<V>> {
            return SortedAsMap(sortedMap().tailMap(fromKey))
        }

        // returns a SortedSet, even though returning a Set would be sufficient to
        // satisfy the SortedMap.keySet() interface
        override fun keySet(): SortedSet<K> {
            val result = sortedKeySet
            return result ?: (sortedKeySet = createKeySet())
        }

        internal override fun createKeySet(): SortedSet<K> {
            return SortedKeySet(sortedMap())
        }
    }

    internal inner class NavigableAsMap(submap: NavigableMap<K, Collection<V>>) : SortedAsMap(submap), NavigableMap<K, Collection<V>> {

        override fun sortedMap(): NavigableMap<K, Collection<V>> {
            return super.sortedMap() as NavigableMap<K, Collection<V>>
        }

        override fun lowerEntry(key: K): Entry<K, Collection<V>>? {
            val entry = sortedMap().lowerEntry(key)
            return if (entry == null) null else wrapEntry(entry)
        }

        override fun lowerKey(key: K): K {
            return sortedMap().lowerKey(key)
        }

        override fun floorEntry(key: K): Entry<K, Collection<V>>? {
            val entry = sortedMap().floorEntry(key)
            return if (entry == null) null else wrapEntry(entry)
        }

        override fun floorKey(key: K): K {
            return sortedMap().floorKey(key)
        }

        override fun ceilingEntry(key: K): Entry<K, Collection<V>>? {
            val entry = sortedMap().ceilingEntry(key)
            return if (entry == null) null else wrapEntry(entry)
        }

        override fun ceilingKey(key: K): K {
            return sortedMap().ceilingKey(key)
        }

        override fun higherEntry(key: K): Entry<K, Collection<V>>? {
            val entry = sortedMap().higherEntry(key)
            return if (entry == null) null else wrapEntry(entry)
        }

        override fun higherKey(key: K): K {
            return sortedMap().higherKey(key)
        }

        override fun firstEntry(): Entry<K, Collection<V>>? {
            val entry = sortedMap().firstEntry()
            return if (entry == null) null else wrapEntry(entry)
        }

        override fun lastEntry(): Entry<K, Collection<V>>? {
            val entry = sortedMap().lastEntry()
            return if (entry == null) null else wrapEntry(entry)
        }

        override fun pollFirstEntry(): Entry<K, Collection<V>>? {
            return pollAsMapEntry(entries.iterator())
        }

        override fun pollLastEntry(): Entry<K, Collection<V>>? {
            return pollAsMapEntry(descendingMap().entries.iterator())
        }

        fun pollAsMapEntry(entryIterator: MutableIterator<Entry<K, Collection<V>>>): Entry<K, Collection<V>>? {
            if (!entryIterator.hasNext()) {
                return null
            }
            val entry = entryIterator.next()
            val output = createCollection()
            output.addAll(entry.value)
            entryIterator.remove()
            return Maps.immutableEntry(entry.key, unmodifiableCollectionSubclass(output))
        }

        override fun descendingMap(): NavigableMap<K, Collection<V>> {
            return NavigableAsMap(sortedMap().descendingMap())
        }

        override fun keySet(): NavigableSet<K> {
            return super.keys as NavigableSet<K>
        }

        override fun createKeySet(): NavigableSet<K> {
            return NavigableKeySet(sortedMap())
        }

        override fun navigableKeySet(): NavigableSet<K> {
            return keys
        }

        override fun descendingKeySet(): NavigableSet<K> {
            return descendingMap().navigableKeySet()
        }

        override fun subMap(fromKey: K, toKey: K): NavigableMap<K, Collection<V>> {
            return subMap(fromKey, true, toKey, false)
        }

        override fun subMap(
                fromKey: K, fromInclusive: Boolean, toKey: K, toInclusive: Boolean): NavigableMap<K, Collection<V>> {
            return NavigableAsMap(sortedMap().subMap(fromKey, fromInclusive, toKey, toInclusive))
        }

        override fun headMap(toKey: K): NavigableMap<K, Collection<V>> {
            return headMap(toKey, false)
        }

        override fun headMap(toKey: K, inclusive: Boolean): NavigableMap<K, Collection<V>> {
            return NavigableAsMap(sortedMap().headMap(toKey, inclusive))
        }

        override fun tailMap(fromKey: K): NavigableMap<K, Collection<V>> {
            return tailMap(fromKey, true)
        }

        override fun tailMap(fromKey: K, inclusive: Boolean): NavigableMap<K, Collection<V>> {
            return NavigableAsMap(sortedMap().tailMap(fromKey, inclusive))
        }
    }

    companion object {

        private fun <E> iteratorOrListIterator(collection: Collection<E>): MutableIterator<E> {
            return if (collection is List<*>)
                (collection as List<E>).listIterator()
            else
                collection.iterator()
        }

        private const val serialVersionUID = 2447537837011683357L
    }
}
